<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Authentication & Authorization – ניהול הרשאות משתמשים - React Project
      Guidelines
    </title>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Authentication & Authorization – ניהול הרשאות משתמשים</h1>
      </header>
      <nav>
        <a href="../index.html">← חזרה לדף הבית</a>
      </nav>

      <section class="category">
        <h2>למה Authentication & Authorization חשובים?</h2>
        <p>
          בפיתוח אפליקציות React, ניהול משתמשים והרשאות הוא מרכיב קריטי.
          Authentication ו‑Authorization מאפשרים לאפליקציה לדעת מי המשתמש ומה
          הוא רשאי לבצע.
        </p>
        <ul>
          <li>
            מבטיח שרק משתמשים מורשים יקבלו גישה לנתונים רגישים או לפיצ'רים
            מסוימים.
          </li>
          <li>מונע שימוש לא חוקי באפליקציה ושחיתות נתונים.</li>
          <li>משפר חוויית משתמש עם הצגת תוכן מותאם למשתמשים שונים.</li>
          <li>
            קריטי באפליקציות מודרניות עם מספר סוגי משתמשים (Admin, User, Guest
            וכו').
          </li>
        </ul>
      </section>

      <section class="category">
        <h2>עקרונות מפתח</h2>
        <h3>1. Authentication – אימות משתמש</h3>
        <p>
          זיהוי המשתמש דרך login/password או OAuth providers (Google, Facebook,
          GitHub).
        </p>
        <p>שימוש ב‑JWT או session tokens לזיהוי המשתמש לאחר ההתחברות.</p>
        <pre
          dir="ltr"
        ><code>import React, { useState, useContext, createContext } from 'react';
import axios from 'axios';

// Authentication Context
const AuthContext = createContext();

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

export function AuthProvider({ children }) {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);

  const login = async (email, password) => {
    try {
      const response = await axios.post('/api/auth/login', {
        email,
        password,
      });
      
      const { token, user } = response.data;
      
      // Store token securely
      localStorage.setItem('authToken', token);
      
      // Set axios default header
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      
      setUser(user);
      return { success: true };
    } catch (error) {
      return { 
        success: false, 
        error: error.response?.data?.message || 'Login failed' 
      };
    }
  };

  const logout = () => {
    localStorage.removeItem('authToken');
    delete axios.defaults.headers.common['Authorization'];
    setUser(null);
  };

  const checkAuth = async () => {
    const token = localStorage.getItem('authToken');
    if (!token) {
      setLoading(false);
      return;
    }

    try {
      axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;
      const response = await axios.get('/api/auth/me');
      setUser(response.data.user);
    } catch (error) {
      logout();
    } finally {
      setLoading(false);
    }
  };

  React.useEffect(() => {
    checkAuth();
  }, []);

  const value = {
    user,
    login,
    logout,
    loading,
    isAuthenticated: !!user,
  };

  return (
    &lt;AuthContext.Provider value={value}&gt;
      {children}
    &lt;/AuthContext.Provider&gt;
  );
}</code></pre>

        <h3>2. Authorization – הרשאות</h3>
        <p>קביעה מה כל משתמש רשאי לבצע או לראות.</p>
        <p>דוגמה ברמת קומפוננטה ב‑React:</p>
        <pre dir="ltr"><code>// Role-based access control component
function RoleGuard({ allowedRoles, children, fallback = null }) {
  const { user } = useAuth();

  if (!user) {
    return fallback || &lt;div&gt;Please log in&lt;/div&gt;;
  }

  if (!allowedRoles.includes(user.role)) {
    return fallback || &lt;div&gt;Access denied&lt;/div&gt;;
  }

  return children;
}

// Permission-based access control
function PermissionGuard({ requiredPermission, children, fallback = null }) {
  const { user } = useAuth();

  if (!user?.permissions?.includes(requiredPermission)) {
    return fallback || &lt;div&gt;Insufficient permissions&lt;/div&gt;;
  }

  return children;
}

// Usage examples
function AdminPanel() {
  return (
    &lt;RoleGuard allowedRoles={['admin', 'super_admin']}&gt;
      &lt;div&gt;
        &lt;h2&gt;Admin Panel&lt;/h2&gt;
        &lt;button&gt;Manage Users&lt;/button&gt;
        &lt;button&gt;View Analytics&lt;/button&gt;
      &lt;/div&gt;
    &lt;/RoleGuard&gt;
  );
}

function UserSettings() {
  return (
    &lt;div&gt;
      &lt;h2&gt;User Settings&lt;/h2&gt;
      
      &lt;PermissionGuard 
        requiredPermission="edit_profile"
        fallback={&lt;p&gt;You cannot edit your profile&lt;/p&gt;}
      &gt;
        &lt;button&gt;Edit Profile&lt;/button&gt;
      &lt;/PermissionGuard&gt;
      
      &lt;PermissionGuard 
        requiredPermission="delete_account"
        fallback={&lt;p&gt;Contact admin to delete account&lt;/p&gt;}
      &gt;
        &lt;button&gt;Delete Account&lt;/button&gt;
      &lt;/PermissionGuard&gt;
    &lt;/div&gt;
  );
}</code></pre>

        <h3>3. Route Protection</h3>
        <p>
          שימוש ב‑React Router כדי למנוע גישה ל‑routes עבור משתמשים לא מורשים:
        </p>
        <pre
          dir="ltr"
        ><code>import { Navigate, useLocation } from 'react-router-dom';

// Protected Route Component
function ProtectedRoute({ children, requiredRole = null }) {
  const { user, loading } = useAuth();
  const location = useLocation();

  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  if (!user) {
    // Redirect to login page with return url
    return &lt;Navigate to="/login" state={{ from: location }} replace /&gt;;
  }

  if (requiredRole && user.role !== requiredRole) {
    return &lt;Navigate to="/unauthorized" replace /&gt;;
  }

  return children;
}

// Public Route (redirect to dashboard if already logged in)
function PublicRoute({ children }) {
  const { user, loading } = useAuth();

  if (loading) {
    return &lt;div&gt;Loading...&lt;/div&gt;;
  }

  if (user) {
    return &lt;Navigate to="/dashboard" replace /&gt;;
  }

  return children;
}

// App routing setup
function App() {
  return (
    &lt;AuthProvider&gt;
      &lt;BrowserRouter&gt;
        &lt;Routes&gt;
          {/* Public routes */}
          &lt;Route 
            path="/login" 
            element={
              &lt;PublicRoute&gt;
                &lt;LoginPage /&gt;
              &lt;/PublicRoute&gt;
            } 
          /&gt;
          
          {/* Protected routes */}
          &lt;Route 
            path="/dashboard" 
            element={
              &lt;ProtectedRoute&gt;
                &lt;Dashboard /&gt;
              &lt;/ProtectedRoute&gt;
            } 
          /&gt;
          
          &lt;Route 
            path="/admin" 
            element={
              &lt;ProtectedRoute requiredRole="admin"&gt;
                &lt;AdminPanel /&gt;
              &lt;/ProtectedRoute&gt;
            } 
          /&gt;
          
          &lt;Route path="/unauthorized" element={&lt;UnauthorizedPage /&gt;} /&gt;
        &lt;/Routes&gt;
      &lt;/BrowserRouter&gt;
    &lt;/AuthProvider&gt;
  );
}</code></pre>

        <h3>4. Token Handling</h3>
        <p>
          שמירת tokens בצורה בטוחה, טיפול ב‑refresh tokens ובדיקה תקופתית של
          תוקף ה‑token:
        </p>
        <pre dir="ltr"><code>// Token management utilities
class TokenManager {
  private static readonly ACCESS_TOKEN_KEY = 'access_token';
  private static readonly REFRESH_TOKEN_KEY = 'refresh_token';

  static setTokens(accessToken: string, refreshToken: string): void {
    localStorage.setItem(this.ACCESS_TOKEN_KEY, accessToken);
    localStorage.setItem(this.REFRESH_TOKEN_KEY, refreshToken);
  }

  static getAccessToken(): string | null {
    return localStorage.getItem(this.ACCESS_TOKEN_KEY);
  }

  static getRefreshToken(): string | null {
    return localStorage.getItem(this.REFRESH_TOKEN_KEY);
  }

  static clearTokens(): void {
    localStorage.removeItem(this.ACCESS_TOKEN_KEY);
    localStorage.removeItem(this.REFRESH_TOKEN_KEY);
  }

  static isTokenExpired(token: string): boolean {
    try {
      const payload = JSON.parse(atob(token.split('.')[1]));
      const currentTime = Date.now() / 1000;
      return payload.exp < currentTime;
    } catch {
      return true;
    }
  }
}

// Axios interceptor for automatic token refresh
axios.interceptors.request.use(
  (config) => {
    const token = TokenManager.getAccessToken();
    if (token && !TokenManager.isTokenExpired(token)) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response?.status === 401 && !originalRequest._retry) {
      originalRequest._retry = true;

      try {
        const refreshToken = TokenManager.getRefreshToken();
        if (!refreshToken) {
          throw new Error('No refresh token');
        }

        const response = await axios.post('/api/auth/refresh', {
          refreshToken,
        });

        const { accessToken, refreshToken: newRefreshToken } = response.data;
        TokenManager.setTokens(accessToken, newRefreshToken);

        // Retry original request with new token
        originalRequest.headers.Authorization = `Bearer ${accessToken}`;
        return axios(originalRequest);
      } catch (refreshError) {
        TokenManager.clearTokens();
        window.location.href = '/login';
        return Promise.reject(refreshError);
      }
    }

    return Promise.reject(error);
  }
);</code></pre>
      </section>

      <section class="category">
        <h2>Custom Hooks לניהול הרשאות</h2>
        <pre dir="ltr"><code>// Custom hooks for permissions
function usePermissions() {
  const { user } = useAuth();

  const hasRole = useCallback((role: string) => {
    return user?.role === role;
  }, [user]);

  const hasPermission = useCallback((permission: string) => {
    return user?.permissions?.includes(permission) || false;
  }, [user]);

  const hasAnyRole = useCallback((roles: string[]) => {
    return roles.some(role => hasRole(role));
  }, [hasRole]);

  const hasAnyPermission = useCallback((permissions: string[]) => {
    return permissions.some(permission => hasPermission(permission));
  }, [hasPermission]);

  return {
    hasRole,
    hasPermission,
    hasAnyRole,
    hasAnyPermission,
    isAdmin: hasRole('admin'),
    isUser: hasRole('user'),
  };
}

// Usage in components
function UserDashboard() {
  const { hasPermission, isAdmin } = usePermissions();

  return (
    &lt;div&gt;
      &lt;h1&gt;Dashboard&lt;/h1&gt;
      
      {hasPermission('view_analytics') && (
        &lt;div&gt;
          &lt;h2&gt;Analytics&lt;/h2&gt;
          &lt;AnalyticsChart /&gt;
        &lt;/div&gt;
      )}
      
      {isAdmin && (
        &lt;div&gt;
          &lt;h2&gt;Admin Actions&lt;/h2&gt;
          &lt;button&gt;Manage Users&lt;/button&gt;
          &lt;button&gt;System Settings&lt;/button&gt;
        &lt;/div&gt;
      )}
    &lt;/div&gt;
  );
}</code></pre>
      </section>

      <section class="category">
        <h2>טיפים למימוש יעיל</h2>
        <ul>
          <li>
            להפריד בין Authentication ל‑Authorization – זה מאפשר קוד ברור
            ותחזוקתי.
          </li>
          <li>לאחסן מידע רגיש בצורה מוצפנת ולא ב‑localStorage חשוף.</li>
          <li>
            להשתמש ב‑context או state management לניהול סטטוס המשתמש ב‑UI.
          </li>
          <li>לשלב logging וניטור כדי לזהות ניסיונות גישה לא מורשים.</li>
          <li>לבדוק הרשאות גם בצד הלקוח וגם בצד השרת.</li>
          <li>להשתמש ב‑TypeScript להגדרת סוגי משתמשים והרשאות.</li>
        </ul>
      </section>

      <section class="category">
        <h2>סיכום</h2>
        <p>
          Authentication & Authorization הם הבסיס לאפליקציות React מאובטחות
          ואמינות. ניהול נכון של אימות והגדרות הרשאות מאפשר חוויית משתמש מותאמת,
          מונע חדירות ושומר על אינטגריטי הנתונים.
        </p>
      </section>
    </main>
  </body>
</html>
