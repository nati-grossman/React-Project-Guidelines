<!DOCTYPE html>
<html lang="he" dir="rtl">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>
      Bundle Optimization – Tree Shaking ו‑Minification - React Project
      Guidelines
    </title>
    <link rel="stylesheet" href="../styles.css" />
  </head>
  <body>
    <main class="container">
      <header>
        <h1>Bundle Optimization – Tree Shaking ו‑Minification</h1>
      </header>
      <nav>
        <a href="../index.html">← חזרה לדף הבית</a>
      </nav>

      <section class="category">
        <h2>למה Bundle Optimization חשוב?</h2>
        <p>
          בפיתוח React מודרני, גודל חבילת ה‑JavaScript משפיע ישירות על ביצועי
          האפליקציה. Bundle Optimization מאפשר להפחית את כמות הקוד שנשלח לדפדפן,
          לטעון רק את מה שצריך ולשפר את זמן הטעינה.
        </p>
        <ul>
          <li>מקטין את זמן הטעינה הראשוני של האפליקציה.</li>
          <li>משפר את performance ה‑runtime וה‑perceived performance.</li>
          <li>
            מפחית שימוש ברוחב פס, מה שמועיל במיוחד למשתמשים במובייל או בחיבורים
            איטיים.
          </li>
          <li>מאפשר תחזוקה נוחה יותר של קוד מודולרי וגדול.</li>
        </ul>
      </section>

      <section class="category">
        <h2>עקרונות מפתח</h2>
        <h3>1. Tree Shaking</h3>
        <p>
          תהליך שמסיר קוד לא בשימוש מה bundle. עובד היטב עם ES Modules
          (import/export).
        </p>
        <pre dir="ltr"><code>// ❌ רע - import של ספרייה שלמה
import * as lodash from 'lodash';
const result = lodash.pick(obj, ['name', 'age']);

// ✅ טוב - import של פונקציה ספציפית
import { pick } from 'lodash';
const result = pick(obj, ['name', 'age']);

// ✅ עוד יותר טוב - import ישיר של הפונקציה
import pick from 'lodash/pick';
const result = pick(obj, ['name', 'age']);

// utils.ts - Example module
export const usedFunction = () => {
  return 'This function is used';
};

export const unusedFunction = () => {
  return 'This function will be tree-shaken out';
};

export const anotherUsedFunction = () => {
  return 'This is also used';
};

// main.ts - Only importing what we need
import { usedFunction, anotherUsedFunction } from './utils';

// Only usedFunction and anotherUsedFunction will be included in bundle
// unusedFunction will be removed by tree shaking
console.log(usedFunction());
console.log(anotherUsedFunction());</code></pre>

        <h3>2. Webpack Tree Shaking Configuration</h3>
        <pre dir="ltr"><code>// webpack.config.js
module.exports = {
  mode: 'production', // Enables tree shaking
  optimization: {
    usedExports: true,
    sideEffects: false, // Indicates no side effects in modules
  },
};

// package.json - Marking side-effect free modules
{
  "name": "my-react-app",
  "sideEffects": false, // All modules are side-effect free
  // Or specify which files have side effects
  "sideEffects": [
    "*.css",
    "*.scss",
    "./src/polyfills.js"
  ]
}

// Advanced webpack optimization
module.exports = {
  mode: 'production',
  optimization: {
    usedExports: true,
    sideEffects: false,
    minimize: true,
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true, // Remove console.log in production
            drop_debugger: true,
            pure_funcs: ['console.log', 'console.info'],
          },
          mangle: {
            safari10: true,
          },
        },
      }),
    ],
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
        },
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          enforce: true,
        },
      },
    },
  },
};</code></pre>

        <h3>3. Library-Specific Tree Shaking</h3>
        <pre dir="ltr"><code>// Material-UI - Tree shaking friendly imports
// ❌ רע - imports all of Material-UI
import { Button, TextField } from '@material-ui/core';

// ✅ טוב - individual imports
import Button from '@material-ui/core/Button';
import TextField from '@material-ui/core/TextField';

// Lodash - Tree shaking
// ❌ רע
import _ from 'lodash';
const result = _.map(array, item => item.id);

// ✅ טוב
import map from 'lodash/map';
const result = map(array, item => item.id);

// ✅ עם babel-plugin-lodash
import { map, filter, reduce } from 'lodash';
// Plugin automatically converts to individual imports

// React Icons - Tree shaking
// ❌ רע
import * as FaIcons from 'react-icons/fa';

// ✅ טוב
import { FaUser, FaHome } from 'react-icons/fa';

// Date libraries - Tree shaking friendly
// ❌ רע - moment.js (large bundle)
import moment from 'moment';

// ✅ טוב - date-fns (tree-shakeable)
import { format, addDays } from 'date-fns';

// ✅ עוד יותר טוב - day.js (smaller alternative)
import dayjs from 'dayjs';</code></pre>

        <h3>4. Minification Strategies</h3>
        <pre dir="ltr"><code>// Terser configuration for React
const TerserPlugin = require('terser-webpack-plugin');

module.exports = {
  optimization: {
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          parse: {
            ecma: 8,
          },
          compress: {
            ecma: 5,
            warnings: false,
            comparisons: false,
            inline: 2,
            drop_console: true,
            drop_debugger: true,
            pure_funcs: [
              'console.log',
              'console.info',
              'console.debug',
              'console.warn',
            ],
          },
          mangle: {
            safari10: true,
          },
          output: {
            ecma: 5,
            comments: false,
            ascii_only: true,
          },
        },
        parallel: true,
        cache: true,
        sourceMap: false, // Set to true for debugging
      }),
    ],
  },
};

// CSS Minification
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');

module.exports = {
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css',
      chunkFilename: '[id].[contenthash].css',
    }),
  ],
  optimization: {
    minimizer: [
      new OptimizeCSSAssetsPlugin({
        cssProcessorOptions: {
          safe: true,
          discardComments: {
            removeAll: true,
          },
        },
      }),
    ],
  },
};</code></pre>

        <h3>5. Bundle Analysis ו-Monitoring</h3>
        <pre dir="ltr"><code>// webpack-bundle-analyzer
const BundleAnalyzerPlugin = require('webpack-bundle-analyzer').BundleAnalyzerPlugin;

module.exports = {
  plugins: [
    new BundleAnalyzerPlugin({
      analyzerMode: 'static',
      openAnalyzer: false,
      reportFilename: 'bundle-report.html',
    }),
  ],
};

// Package.json scripts for analysis
{
  "scripts": {
    "analyze": "npm run build && npx webpack-bundle-analyzer build/static/js/*.js",
    "analyze:server": "npm run build && npx webpack-bundle-analyzer build/static/js/*.js --mode server",
    "build:analyze": "ANALYZE=true npm run build"
  }
}

// Bundle size monitoring utility
function logBundleSize() {
  if (process.env.NODE_ENV === 'development') {
    console.log('📦 Bundle Analysis:');
    
    // Monitor chunk loading
    const originalCreateElement = document.createElement;
    document.createElement = function(tagName) {
      const element = originalCreateElement.call(this, tagName);
      
      if (tagName === 'script' && element.src) {
        console.log('Loading script:', element.src);
        
        element.onload = () => {
          console.log('Script loaded:', element.src);
        };
        
        element.onerror = () => {
          console.error('Script failed to load:', element.src);
        };
      }
      
      return element;
    };
  }
}

// Performance budget configuration
module.exports = {
  performance: {
    hints: 'warning',
    maxEntrypointSize: 250000, // 250kb
    maxAssetSize: 250000,
  },
};

// Custom webpack plugin for bundle size monitoring
class BundleSizePlugin {
  apply(compiler) {
    compiler.hooks.afterEmit.tap('BundleSizePlugin', (compilation) => {
      const assets = compilation.assets;
      
      console.log('\n📊 Bundle Size Report:');
      Object.keys(assets).forEach(filename => {
        const size = assets[filename].size();
        const sizeKB = (size / 1024).toFixed(2);
        
        if (filename.endsWith('.js')) {
          console.log(`📄 ${filename}: ${sizeKB} KB`);
          
          if (size > 250000) {
            console.warn(`⚠️  ${filename} exceeds 250KB budget!`);
          }
        }
      });
    });
  }
}</code></pre>
      </section>

      <section class="category">
        <h2>Advanced Optimization Techniques</h2>
        <h3>1. Dynamic Imports עם Tree Shaking</h3>
        <pre dir="ltr"><code>// Conditional loading with tree shaking
const loadChartLibrary = async (chartType) => {
  switch (chartType) {
    case 'line':
      const { LineChart } = await import('./charts/LineChart');
      return LineChart;
    case 'bar':
      const { BarChart } = await import('./charts/BarChart');
      return BarChart;
    case 'pie':
      const { PieChart } = await import('./charts/PieChart');
      return PieChart;
    default:
      throw new Error('Unknown chart type');
  }
};

// Smart polyfill loading
const loadPolyfills = async () => {
  const promises = [];
  
  if (!window.IntersectionObserver) {
    promises.push(import('intersection-observer'));
  }
  
  if (!window.ResizeObserver) {
    promises.push(import('resize-observer-polyfill'));
  }
  
  if (!window.fetch) {
    promises.push(import('whatwg-fetch'));
  }
  
  await Promise.all(promises);
};

// Feature-based module loading
const loadFeatureModule = async (featureName) => {
  const modules = {
    'user-management': () => import('./features/UserManagement'),
    'analytics': () => import('./features/Analytics'),
    'reporting': () => import('./features/Reporting'),
  };
  
  const moduleLoader = modules[featureName];
  if (!moduleLoader) {
    throw new Error(`Feature ${featureName} not found`);
  }
  
  return moduleLoader();
};</code></pre>

        <h3>2. Vendor Bundle Optimization</h3>
        <pre dir="ltr"><code>// Advanced code splitting configuration
module.exports = {
  optimization: {
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        // Large libraries in separate chunks
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          chunks: 'all',
        },
        materialUI: {
          test: /[\\/]node_modules[\\/]@material-ui[\\/]/,
          name: 'material-ui',
          chunks: 'all',
        },
        lodash: {
          test: /[\\/]node_modules[\\/]lodash[\\/]/,
          name: 'lodash',
          chunks: 'all',
        },
        // Common vendor libraries
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: -10,
        },
        // App-specific common code
        common: {
          name: 'common',
          minChunks: 2,
          chunks: 'all',
          priority: -20,
        },
      },
    },
  },
};

// Bundle externals for CDN loading
module.exports = {
  externals: {
    react: 'React',
    'react-dom': 'ReactDOM',
    lodash: '_',
  },
};

// HTML template with CDN scripts
&lt;script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"&gt;&lt;/script&gt;
&lt;script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"&gt;&lt;/script&gt;</code></pre>

        <h3>3. Build-Time Optimizations</h3>
        <pre dir="ltr"><code>// Babel configuration for optimal tree shaking
{
  "presets": [
    [
      "@babel/preset-env",
      {
        "modules": false, // Preserve ES modules for tree shaking
        "useBuiltIns": "usage",
        "corejs": 3
      }
    ],
    "@babel/preset-react"
  ],
  "plugins": [
    // Transform imports for better tree shaking
    [
      "babel-plugin-import",
      {
        "libraryName": "@material-ui/core",
        "libraryDirectory": "",
        "camel2DashComponentName": false
      }
    ],
    // Lodash optimization
    "babel-plugin-lodash",
    // Remove PropTypes in production
    ["babel-plugin-transform-react-remove-prop-types", {
      "mode": "remove",
      "removeImport": true,
      "ignoreFilenames": ["node_modules"]
    }]
  ]
}

// ESLint rules for bundle optimization
{
  "rules": {
    "import/no-unused-modules": [1, {
      "unusedExports": true
    }],
    "no-unused-vars": "error",
    "tree-shaking/no-side-effects-in-initialization": "error"
  }
}

// TypeScript configuration for tree shaking
{
  "compilerOptions": {
    "module": "esnext",
    "moduleResolution": "node",
    "target": "es5",
    "lib": ["dom", "dom.iterable", "es6"],
    "allowJs": true,
    "skipLibCheck": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "strict": true,
    "forceConsistentCasingInFileNames": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "react-jsx"
  }
}</code></pre>
      </section>

      <section class="category">
        <h2>Performance Monitoring ו-Optimization</h2>
        <pre dir="ltr"><code>// Bundle performance tracking
class BundlePerformanceMonitor {
  constructor() {
    this.chunkLoadTimes = new Map();
    this.startTime = performance.now();
  }

  trackChunkLoad(chunkName) {
    const startTime = performance.now();
    
    return {
      end: () => {
        const loadTime = performance.now() - startTime;
        this.chunkLoadTimes.set(chunkName, loadTime);
        
        console.log(`📦 Chunk "${chunkName}" loaded in ${loadTime.toFixed(2)}ms`);
        
        // Send to analytics
        if (window.gtag) {
          window.gtag('event', 'chunk_load_time', {
            chunk_name: chunkName,
            load_time: Math.round(loadTime),
          });
        }
      }
    };
  }

  getReport() {
    const totalTime = performance.now() - this.startTime;
    const report = {
      totalLoadTime: totalTime,
      chunkLoadTimes: Object.fromEntries(this.chunkLoadTimes),
      averageChunkLoadTime: Array.from(this.chunkLoadTimes.values())
        .reduce((sum, time) => sum + time, 0) / this.chunkLoadTimes.size
    };
    
    console.table(report);
    return report;
  }
}

// Usage
const performanceMonitor = new BundlePerformanceMonitor();

// Track dynamic imports
const loadComponent = async (componentName) => {
  const tracker = performanceMonitor.trackChunkLoad(componentName);
  
  try {
    const module = await import(`./components/${componentName}`);
    tracker.end();
    return module.default;
  } catch (error) {
    tracker.end();
    throw error;
  }
};

// Automated bundle size alerts
const checkBundleSize = () => {
  const MAX_BUNDLE_SIZE = 250 * 1024; // 250KB
  
  if ('connection' in navigator) {
    const connection = navigator.connection;
    const isSlowConnection = connection.effectiveType === 'slow-2g' || 
                           connection.effectiveType === '2g';
    
    if (isSlowConnection) {
      console.warn('⚠️ Slow connection detected. Consider lazy loading more components.');
    }
  }
  
  // Check if we can get bundle size info
  if (window.performance && window.performance.getEntriesByType) {
    const resources = window.performance.getEntriesByType('resource');
    const jsResources = resources.filter(r => r.name.endsWith('.js'));
    
    jsResources.forEach(resource => {
      if (resource.transferSize > MAX_BUNDLE_SIZE) {
        console.warn(`⚠️ Large bundle detected: ${resource.name} (${(resource.transferSize / 1024).toFixed(2)}KB)`);
      }
    });
  }
};</code></pre>
      </section>

      <section class="category">
        <h2>טיפים למימוש יעיל</h2>
        <ul>
          <li>
            להשתמש ב‑ES Modules במקום CommonJS כדי לאפשר Tree Shaking אופטימלי.
          </li>
          <li>לוודא שהספריות שאתה משתמש בהן תומכות ב‑tree shaking.</li>
          <li>
            לשלב עם tools כמו Webpack, Vite או Rollup לניהול bundle מתקדם.
          </li>
          <li>
            לבדוק את Bundle Size עם Bundle Analyzer כדי להבין מה נכלל ומה ניתן
            להסיר.
          </li>
          <li>להימנע מ-side effects לא הכרחיים בקוד הספרייה.</li>
          <li>להשתמש ב-dynamic imports עבור קוד שלא נדרש מיד.</li>
          <li>לנטר bundle size כחלק מ-CI/CD pipeline.</li>
          <li>
            לבחור ספריות קטנות וmodular (date-fns במקום moment, lodash עם
            imports ספציפיים).
          </li>
          <li>להסיר dev dependencies ו-debugging code בפרודקשן.</li>
        </ul>
      </section>

      <section class="category">
        <h2>דוגמה מקיפה - Optimized Build Pipeline</h2>
        <pre dir="ltr"><code>// Complete webpack optimization configuration
const path = require('path');
const TerserPlugin = require('terser-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');

module.exports = {
  mode: 'production',
  entry: './src/index.js',
  output: {
    path: path.resolve(__dirname, 'dist'),
    filename: '[name].[contenthash].js',
    chunkFilename: '[name].[contenthash].chunk.js',
    clean: true,
  },
  
  optimization: {
    usedExports: true,
    sideEffects: false,
    
    minimizer: [
      new TerserPlugin({
        terserOptions: {
          compress: {
            drop_console: true,
            drop_debugger: true,
            pure_funcs: ['console.log'],
          },
          mangle: true,
        },
      }),
    ],
    
    splitChunks: {
      chunks: 'all',
      cacheGroups: {
        react: {
          test: /[\\/]node_modules[\\/](react|react-dom)[\\/]/,
          name: 'react',
          chunks: 'all',
        },
        vendor: {
          test: /[\\/]node_modules[\\/]/,
          name: 'vendors',
          chunks: 'all',
          priority: -10,
        },
      },
    },
  },
  
  plugins: [
    new MiniCssExtractPlugin({
      filename: '[name].[contenthash].css',
    }),
    
    ...(process.env.ANALYZE ? [new BundleAnalyzerPlugin()] : []),
  ],
  
  module: {
    rules: [
      {
        test: /\.jsx?$/,
        exclude: /node_modules/,
        use: {
          loader: 'babel-loader',
          options: {
            presets: [
              ['@babel/preset-env', { modules: false }],
              '@babel/preset-react',
            ],
            plugins: [
              'babel-plugin-lodash',
              ['babel-plugin-import', {
                libraryName: '@material-ui/core',
                libraryDirectory: '',
                camel2DashComponentName: false,
              }],
            ],
          },
        },
      },
    ],
  },
  
  resolve: {
    alias: {
      '@': path.resolve(__dirname, 'src'),
    },
  },
};</code></pre>
      </section>

      <section class="category">
        <h2>סיכום</h2>
        <p>
          Bundle Optimization באמצעות Tree Shaking ו‑Minification היא דרך חיונית
          לשפר ביצועים באפליקציות React. שילוב של קוד מודולרי, build tools
          נכונים, ניתוח חכם ומעקב ביצועים מבטיח אפליקציה מהירה, קלה לתחזוקה
          וחסכונית ברוחב פס.
        </p>
      </section>
    </main>
  </body>
</html>
